{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Scoutr was built as a means to provide a simple way to put an API in front of a NoSQL backend and ensure full role-based access control (RBAC) integration with audit logging. A Go implementation is available at scoutr-go .","title":"About"},{"location":"#about","text":"Scoutr was built as a means to provide a simple way to put an API in front of a NoSQL backend and ensure full role-based access control (RBAC) integration with audit logging. A Go implementation is available at scoutr-go .","title":"About"},{"location":"example/","text":"Sample implementation An sample implementation of this project is provided in the example folder.","title":"Example"},{"location":"example/#sample-implementation","text":"An sample implementation of this project is provided in the example folder.","title":"Sample implementation"},{"location":"providers/","text":"Scoutr has support for three providers: AWS DynamoDB GCP Firestore MongoDB AWS DynamoDB The DynamoDB provider is implemented in the DynamoAPI class. GCP Firestore The Firestore provider is implemented in the FirestoreAPI class. MongoDB The MongoDB provider is implemented in the MongoAPI class.","title":"Providers"},{"location":"providers/#aws-dynamodb","text":"The DynamoDB provider is implemented in the DynamoAPI class.","title":"AWS DynamoDB"},{"location":"providers/#gcp-firestore","text":"The Firestore provider is implemented in the FirestoreAPI class.","title":"GCP Firestore"},{"location":"providers/#mongodb","text":"The MongoDB provider is implemented in the MongoAPI class.","title":"MongoDB"},{"location":"getting-started/configuration/","text":"All providers require that a Config object be passed in to tell Scoutr about your environment. The configuration accepts the following arguments: Arguments Data Table Name of the table that contains the data being protected by Scoutr Auth Table Name of the auth table Groups Table Name of the groups table Audit Table Name of the audit table. If this is empty, then audit logging is disabled. Primary Key Primary key in your data table Log Retention Days Number of days to retain the read accesses in the Audit logs table. This requires a provider that supports a TTL attribute to expire records. OIDC Username Header Name of the OIDC header that contains the username value. Only applies when using OIDC for authentication. OIDC Email Header Name of the OIDC header that contains the email value. Only applies when using OIDC for authentication. OIDC Groups Header Name of the OIDC header that contains a comma-separated list of groups the user is a member of. Only applies when using OIDC for authentication. OIDC Name Header Name of the OIDC header that contains the user's name value. This can also be a tuple of strings if your OIDC provider splits up first name and last name in separate headers. Only applies when using OIDC for authentication. Connection String (MongoDB only) Connection string used to connect to MongoDB Database Name (MongoDB Only) Name of the database in MongoDB to use Example Python config = Config ( data_table = 'example-data' , auth_table = 'example-auth' , groups_table = 'example-groups' , audit_table = 'example-audit' , primary_key = 'key' , log_retention_days = 30 , oidc_username_header = 'Oidc-Claim-Sub' , oidc_email_header = 'Oidc-Claim-Mail' , oidc_groups_header = 'Oidc-Claim-Groups' , oidc_name_header = ( 'Oidc-Claim-Firstname' , 'Oidc-Claim-Lastname' ) ) # For MongoDB, additional arguments are required to tell Scoutr about the MongoDB connection string and database mongo_config = MongoConfig ( connection_string = 'mongodb://localhost' , database = 'example' , data_table = 'example-data' , auth_table = 'example-auth' , groups_table = 'example-groups' , audit_table = 'example-audit' , primary_key = 'key' , log_retention_days = 30 , oidc_username_header = 'Oidc-Claim-Sub' , oidc_email_header = 'Oidc-Claim-Mail' , oidc_groups_header = 'Oidc-Claim-Groups' , oidc_name_header = ( 'Oidc-Claim-Firstname' , 'Oidc-Claim-Lastname' ) ) dynamo_api = DynamoAPI ( config ) firestore_api = FirestoreAPI ( config ) mongo_api = MongoAPI ( mongo_config ) Go config := Config { DataTable : \"example-data\" , AuthTable : \"example-auth\" , GroupsTable : \"example-groups\" , AuditTable : \"example-audit\" , PrimaryKey : \"key\" , LogRetentionDays : 30 , OIDCUsernameHeader : \"Oidc-Claim-Sub\" , OIDCEmailHeader : \"Oidc-Claim-Mail\" , OIDCGroupsHeader : \"Oidc-Claim-Groups\" , OIDCNameHeader : \"Oidc-Claim-Name\" , } dynamoApi := DynamoAPI ( config ) firestoreApi := FirestoreAPI ( config )","title":"Configuration"},{"location":"getting-started/configuration/#arguments","text":"","title":"Arguments"},{"location":"getting-started/configuration/#data-table","text":"Name of the table that contains the data being protected by Scoutr","title":"Data Table"},{"location":"getting-started/configuration/#auth-table","text":"Name of the auth table","title":"Auth Table"},{"location":"getting-started/configuration/#groups-table","text":"Name of the groups table","title":"Groups Table"},{"location":"getting-started/configuration/#audit-table","text":"Name of the audit table. If this is empty, then audit logging is disabled.","title":"Audit Table"},{"location":"getting-started/configuration/#primary-key","text":"Primary key in your data table","title":"Primary Key"},{"location":"getting-started/configuration/#log-retention-days","text":"Number of days to retain the read accesses in the Audit logs table. This requires a provider that supports a TTL attribute to expire records.","title":"Log Retention Days"},{"location":"getting-started/configuration/#oidc-username-header","text":"Name of the OIDC header that contains the username value. Only applies when using OIDC for authentication.","title":"OIDC Username Header"},{"location":"getting-started/configuration/#oidc-email-header","text":"Name of the OIDC header that contains the email value. Only applies when using OIDC for authentication.","title":"OIDC Email Header"},{"location":"getting-started/configuration/#oidc-groups-header","text":"Name of the OIDC header that contains a comma-separated list of groups the user is a member of. Only applies when using OIDC for authentication.","title":"OIDC Groups Header"},{"location":"getting-started/configuration/#oidc-name-header","text":"Name of the OIDC header that contains the user's name value. This can also be a tuple of strings if your OIDC provider splits up first name and last name in separate headers. Only applies when using OIDC for authentication.","title":"OIDC Name Header"},{"location":"getting-started/configuration/#connection-string-mongodb-only","text":"Connection string used to connect to MongoDB","title":"Connection String (MongoDB only)"},{"location":"getting-started/configuration/#database-name-mongodb-only","text":"Name of the database in MongoDB to use","title":"Database Name (MongoDB Only)"},{"location":"getting-started/configuration/#example","text":"Python config = Config ( data_table = 'example-data' , auth_table = 'example-auth' , groups_table = 'example-groups' , audit_table = 'example-audit' , primary_key = 'key' , log_retention_days = 30 , oidc_username_header = 'Oidc-Claim-Sub' , oidc_email_header = 'Oidc-Claim-Mail' , oidc_groups_header = 'Oidc-Claim-Groups' , oidc_name_header = ( 'Oidc-Claim-Firstname' , 'Oidc-Claim-Lastname' ) ) # For MongoDB, additional arguments are required to tell Scoutr about the MongoDB connection string and database mongo_config = MongoConfig ( connection_string = 'mongodb://localhost' , database = 'example' , data_table = 'example-data' , auth_table = 'example-auth' , groups_table = 'example-groups' , audit_table = 'example-audit' , primary_key = 'key' , log_retention_days = 30 , oidc_username_header = 'Oidc-Claim-Sub' , oidc_email_header = 'Oidc-Claim-Mail' , oidc_groups_header = 'Oidc-Claim-Groups' , oidc_name_header = ( 'Oidc-Claim-Firstname' , 'Oidc-Claim-Lastname' ) ) dynamo_api = DynamoAPI ( config ) firestore_api = FirestoreAPI ( config ) mongo_api = MongoAPI ( mongo_config ) Go config := Config { DataTable : \"example-data\" , AuthTable : \"example-auth\" , GroupsTable : \"example-groups\" , AuditTable : \"example-audit\" , PrimaryKey : \"key\" , LogRetentionDays : 30 , OIDCUsernameHeader : \"Oidc-Claim-Sub\" , OIDCEmailHeader : \"Oidc-Claim-Mail\" , OIDCGroupsHeader : \"Oidc-Claim-Groups\" , OIDCNameHeader : \"Oidc-Claim-Name\" , } dynamoApi := DynamoAPI ( config ) firestoreApi := FirestoreAPI ( config )","title":"Example"},{"location":"getting-started/installation/","text":"To install Scoutr, install it using Pip. Python 3.6+ is supported. Note that dependencies are installed based on which \"extra\" you use. The extras are tied to each of the ../providers : AWS DynamoDB: pip install scoutr[dynamodb] GCP FireStore: pip install scoutr[firestore] MongoDB: pip install scoutr[mongo] Additionally, if you are using Flask as a backend instead of serverless, you should add the flask extra to your installation command. For example, if you are using DynamoDB as your data backend and Flask as your API: pip install scoutr[dynamodb,flask] Requirements At minimum, three tables are required: a data table, an auth table, and a groups table. Additionally, an optional audit log table can be used to track all API calls and changes to records in the data table. The configuration of each table is detailed next. Data Table The data table contains all of the data that is being protected and served by Scoutr. The primary key of the data table can be anything. Your primary key can be specified in the Scoutr configuration. Auth Table The auth table must have a primary key of id . The table name does not matter, as this is passed in during instantiation. Groups Table The groups table must have a primary key of id . The table name does not matter, as this is passed in during instantiation. Audit Log Table The audit log table must have a primary key of time . For providers that support record expiration using a TTL value, the TTL attribute should be set to expire_time . The table name does not matter, as this is passed in during instantiation. If a value is not specified, it is assumed that no audit logs should be kept.","title":"Installation"},{"location":"getting-started/installation/#requirements","text":"At minimum, three tables are required: a data table, an auth table, and a groups table. Additionally, an optional audit log table can be used to track all API calls and changes to records in the data table. The configuration of each table is detailed next.","title":"Requirements"},{"location":"getting-started/installation/#data-table","text":"The data table contains all of the data that is being protected and served by Scoutr. The primary key of the data table can be anything. Your primary key can be specified in the Scoutr configuration.","title":"Data Table"},{"location":"getting-started/installation/#auth-table","text":"The auth table must have a primary key of id . The table name does not matter, as this is passed in during instantiation.","title":"Auth Table"},{"location":"getting-started/installation/#groups-table","text":"The groups table must have a primary key of id . The table name does not matter, as this is passed in during instantiation.","title":"Groups Table"},{"location":"getting-started/installation/#audit-log-table","text":"The audit log table must have a primary key of time . For providers that support record expiration using a TTL value, the TTL attribute should be set to expire_time . The table name does not matter, as this is passed in during instantiation. If a value is not specified, it is assumed that no audit logs should be kept.","title":"Audit Log Table"},{"location":"reference/access-control/","text":"Scoutr provides full access control over the endpoints a set of users is permitted to call and the output that is returned. This is done using field filters, field exclusions, and permitted endpoints, which are outlined in the next section. This access control functionality is implemented at both a user and a group level. A user can be a member of zero or more groups. The implementation of auth identifiers and groups is outlined in their respective sections. Refer to the Authentication section to learn about the supported authentication types. Field filters Field filters are used to perform pre-filtering of the data before it gets returned to the user and to affect what records users are able to manipulate. Syntax Each field filter should be a list of objects. Each item in this list must be structured as: { \"field\" : \"name of the field to perform filter against\" , \"operator\" : \"optional operator. this defaults to 'eq'\" , \"value\" : \"value to filter\" } Info The supported operators are listed on the filtering page . If you specify an invalid operator, an error will be returned whenever that user attempts to perform a request. When using the in operator to check multiple values, the value field should be formatted as an array like below: { \"field\" : \"name of the field to perform filter against\" , \"operator\" : \"in\" , \"value\" : [ \"value1\" , \"value2\" , \"value3\" ] } Types of field filters There are four types of field filters: read, create, update, and delete filters. Read Filters Read filters are used to configure what data is returned from the data table, prior to any user-requested filters. Refer to the filter merging section for more information on how read filters work. Create Filters Create filters are used to configure conditions that must be satisfied for a user to create a record in the data table. This ensures that a user has permission to set the fields they have included in their request body. If the filter criteria fails, then the request will be denied with an Unauthorized error. The final step is to run field validation . The checks are performed as follows: Ensure the user has permissions to set the fields they have included in their request body using the values in exclude_fields . The idea is that if the user does not have permission to view a field, they also do not have permission to set the value of that field. If any matches are found, the request will be denied. Run field validation as normal Run the create_filters against the request body. This will determine if the user has permission to create a record with the values they have specified. If the filter criteria fails, the request will be denied with an Unauthorized error stating which fields have invalid values. Example If a user has these create filters: { \"create_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"ne\" , \"value\" : \"Standard\" } ] } And they attempt to create the below record: { \"name\" : \"test\" , \"product\" : \"Standard\" } Their request would be denied because product is set to \"Standard\", but the create filters require that it be not equal to \"Standard\". If the request were changed to the following, it would be accepted: { \"name\" : \"test\" , \"product\" : \"Limited\" } Note Users still need permission to access the create endpoint using permitted_endpoints . If they cannot access the endpoint, their request would be denied before any filter criteria is evaluated. Update Filters Update filters are used to configure the conditions that must be satisfied for a user to update a record in the data table. This ensures that a user has permission to set the fields they have included in their request body. If the filter criteria fails, then the request will be denied with an Unauthorized error. The checks are performed as follows: Use update_filters to determine if the user has permission to access the specified record. If no records are returned from the data table, then the record either does not exist or the user does not have permission to update it and a Not Found error will be returned. However, if a record is returned, then the user has permissions to update the record. Use update_fields_permitted , update_fields_restricted , and exclude_fields to determine if the user has permissions to update the fields they specified in the request body. If either of these criteria fail, the request will be denied with an Unauthorized error. Take the contents of the requested item from the data table and merge the user's desired changes with that item. Then, run the update_filters against this combined record. This will determine if the user has permission to make the changes they are requesting to the object. If the filter criteria fails, the request will be denied with an Unauthorized error stating which fields have invalid values. Finally, field validation runs as normal. Example Let's say the user has these permissions: { \"update_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"eq\" , \"value\" : \"a\" } ] } The record they are trying to modify in the database looks like: { \"product\" : \"a\" , \"approved\" : false } If the user tries to perform the below update request: { \"product\" : \"b\" , \"approved\" : true } Then this request will be denied because the update_filters do not permit the user to modify the product key to any value that is not equal to \"a\". However, this update would be permitted because the product key is not being modified from its current value of \"a\": { \"approved\" : true , \"reason\" : \"approved by user\" } Now, let's say that the same user was trying to update the below record: { \"product\" : \"b\" , \"approved\" : false } If the user tried to perform the below request, it would be denied because they do not have permission to update an item where the product key is not equal to \"a\": { \"approved\" : true } Delete Filters Update filters are used to configure the conditions that must be satisfied for a user to delete a record in the data table. If the filter criteria fails, then the request will be denied with an Unauthorized error. Example Let's say the user has these permissions: { \"delete_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"eq\" , \"value\" : \"a\" } ] } The record they are trying to delete in the database looks like: { \"product\" : \"a\" , \"approved\" : false } If the user tries to perform a delete request against that record, it would be permitted because the product key is equal to \"a\". However, if the user attempted to perform a delete request against the below record, it would be denied because the product key is not equal to \"a\": { \"product\" : \"b\" , \"approved\" : false } Filter Merging When a user is assigned multiple filters that target the same key, they are merged together using an OR operation. Then, those filters will be combined together with the filters for other keys using an AND operation. For example, if a user has the below read filters: { \"read_filters\" : [ // I n heri te d fr om group - a { \"field\" : \"product\" , \"operator\" : \"contains\" , \"value\" : \"Standard\" }, // I n heri te d fr om group - b { \"field\" : \"product\" , \"operator\" : \"ne\" , \"value\" : \"Standard Elite\" }, // I n heri te d fr om group - c { \"field\" : \"product_status\" , \"value\" : \"Active\" }, // I n heri te d fr om user { \"field\" : \"target_audience\" , \"value\" : \"Global\" } ] } The below filter expression would be generated: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" These filters will be further merged together with any filters the user specified using another AND operation. For instance, if the user performed these filters on their request: GET /products/?company=ABC&product_status=Pending The generated filter expression would be: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" AND company = \"ABC\" AND product_status = \"Pending\" This will actually produce no results because the filters product_status = \"Active\" and product_status = \"Pending\" are conflicting. The user is intentionally unable to override any filters defined by the administrator. If the user removed their filter for product_status = \"Pending\" and only filtered on company : GET /products/?company=ABC The generated filter expression would be: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" AND company = \"ABC\" And any results that met that criteria would be returned Field exclusions Field exclusions allow for excluding one or more fields from the output of all queries. These fields are from any output during the post-processing phase of all queries. Additionally, if a user attempts to create or update an item that contains a field from this list, the operation will be denied. Syntax [ \"field1\" , \"field2\" ] Permitted endpoints Before taking any action, every call is validated to ensure the user has permissions to perform the call. For convenience, regular expressions can be used within the endpoint field. Syntax [ { \"method\" : \"GET|POST|PUT|DELETE\" , \"endpoint\" : \"/endpoint\" }, { \"method\" : \"GET|POST|PUT|DELETE\" , \"endpoint\" : \"^/endpoint2/.+$\" } ] Groups A group object be made up of: id - Identifier for the group permitted_endpoints - Optional list of permitted endpoints read_filters - Optional list of read filters create_filters - Optional list of create filters update_filters - Optional list of update filters delete_filters - Optional list of delete filters exclude_fields - Optional list of field exclusions update_fields_permitted - Optional list of the only fields that can be updated update_fields_restricted - Optional list of fields to restrict updates for The name of the group table must be passed in to the constructor. Example { \"id\" : \"read-only\" , \"permitted_endpoints\" : [ { \"endpoint\" : \"^/account/.+$\" , \"method\" : \"GET\" }, { \"endpoint\" : \"^/accounts.*$\" , \"method\" : \"GET\" }, { \"endpoint\" : \"^/search/.+$\" , \"method\" : \"POST\" } ], \"exclude_fields\" : [ \"field1\" ], \"update_fields_permitted\" : [ \"field4\" ], \"update_fields_restricted\" : [ \"field5\" ], \"read_filters\" : [ { \"field\" : \"field2\" , \"value\" : \"value1\" }, { \"field\" : \"field3\" , \"operator\" : \"in\" , \"value\" : [ \"value2\" , \"value3\" ] } ] } Auth Identifier An auth record is made up of: id - Identifier for the user/auth record username - Username for this user. This is optional when using OIDC since the information is filled by OIDC. name - Username for this user. This is optional when using OIDC since the information is filled by OIDC. email - Email for this user. This is optional when using OIDC since the information is filled by OIDC. groups - Optional list of groups this user is a member of permitted_endpoints - Optional list of permitted endpoints read_filters - Optional list of read filters create_filters - Optional list of create filters update_filters - Optional list of update filters delete_filters - Optional list of delete filters exclude_fields - Optional list of field exclusions update_fields_permitted - Optional list of the only fields that can be updated update_fields_restricted - Optional list of fields to restrict updates for Types There are three types of accepted authentication identifiers: USERNAME OIDC_GROUP API_KEY Though not required, it is recommended for each object type to have a type key that corresponds to its authentication type (OIDC_GROUP, USERNAME, or API_KEY). The field requirements for each object type are outlined in the following sections USERNAME id (primary key) - this is the user's username Though not required, it is recommended to also include a name field containing the user's full name to make it easier to identify the user at a glance. OIDC_GROUP id (primary key) - this is expected to be the group id Though not required, it is recommended to also include a name field containing the group's display name to make it easier to identify the group at a glance. If a user is a member of more than one OIDC group, the permissions granted by each configured group will be combined together to generate the effective permissions applied to the user. API_KEY id (primary key) - this is the api key id name username email Groups Optionally, each auth object can include a groups object, which should be a list of group ids that the user is a member of: { \"groups\" : [ \"read-only\" , \"view-audit-logs\" ] } Any permissions defined in the groups are combined together to make up the user's permissions. In addition, the same permissions that a group defines ( read_filters , create_filters , update_filters , delete_filters , exclude_fields , update_fields_permitted , update_fields_restricted , permitted_endpoints ) can be expressed at the user level. These permissions will be combined together with the permissions outlined in the groups the user is a member of. Permissions defined at the user level DO NOT override those specified at the group level - they are combined. If a user is a member of multiple OIDC groups, the permissions are combined as explained in the filter merging section. Example { \"id\" : \"johndoe\" , \"type\" : \"API_KEY\" , \"username\" : \"johndoe\" , \"name\" : \"John Doe\" , \"email\" : \"john@doe.com\" , \"groups\" : [ \"read-only\" , \"standard-product-only\" ], \"read_filters\" : [ { \"field\" : \"product\" , \"value\" : \"Limited\" } ] } Audit Logs For every authorized, successful call to the API, an entry will be logged in the audit log table. Each record will follow the below format: { \"action\" : \"CREATE|UPDATE|DELETE|GET|LIST|SEARCH|{CUSTOM-ACTION}\" , \"body\" : { \"key\" : \"value\" }, \"method\" : \"HTTP method from API gateway\" , \"path\" : \"/endpoint/path\" , \"path_params\" : { \"key\" : \"value\" }, \"query_params\" : { \"key\" : \"value\" }, \"resource\" : { \"key\" : \"value\" }, \"time\" : \"2019-10-04T18:44:30.166635\" , \"user\" : { \"api_key_id\" : \"ID\" , \"name\" : \"John Doe\" , \"source_ip\" : \"1.2.3.4\" , \"username\" : \"222222222\" , \"user_agent\" : \"curl\" } } The following fields may not be included or may not have values for all types of actions: body query_params path_params resource","title":"Access control"},{"location":"reference/access-control/#field-filters","text":"Field filters are used to perform pre-filtering of the data before it gets returned to the user and to affect what records users are able to manipulate. Syntax Each field filter should be a list of objects. Each item in this list must be structured as: { \"field\" : \"name of the field to perform filter against\" , \"operator\" : \"optional operator. this defaults to 'eq'\" , \"value\" : \"value to filter\" } Info The supported operators are listed on the filtering page . If you specify an invalid operator, an error will be returned whenever that user attempts to perform a request. When using the in operator to check multiple values, the value field should be formatted as an array like below: { \"field\" : \"name of the field to perform filter against\" , \"operator\" : \"in\" , \"value\" : [ \"value1\" , \"value2\" , \"value3\" ] }","title":"Field filters"},{"location":"reference/access-control/#types-of-field-filters","text":"There are four types of field filters: read, create, update, and delete filters.","title":"Types of field filters"},{"location":"reference/access-control/#read-filters","text":"Read filters are used to configure what data is returned from the data table, prior to any user-requested filters. Refer to the filter merging section for more information on how read filters work.","title":"Read Filters"},{"location":"reference/access-control/#create-filters","text":"Create filters are used to configure conditions that must be satisfied for a user to create a record in the data table. This ensures that a user has permission to set the fields they have included in their request body. If the filter criteria fails, then the request will be denied with an Unauthorized error. The final step is to run field validation . The checks are performed as follows: Ensure the user has permissions to set the fields they have included in their request body using the values in exclude_fields . The idea is that if the user does not have permission to view a field, they also do not have permission to set the value of that field. If any matches are found, the request will be denied. Run field validation as normal Run the create_filters against the request body. This will determine if the user has permission to create a record with the values they have specified. If the filter criteria fails, the request will be denied with an Unauthorized error stating which fields have invalid values.","title":"Create Filters"},{"location":"reference/access-control/#example","text":"If a user has these create filters: { \"create_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"ne\" , \"value\" : \"Standard\" } ] } And they attempt to create the below record: { \"name\" : \"test\" , \"product\" : \"Standard\" } Their request would be denied because product is set to \"Standard\", but the create filters require that it be not equal to \"Standard\". If the request were changed to the following, it would be accepted: { \"name\" : \"test\" , \"product\" : \"Limited\" } Note Users still need permission to access the create endpoint using permitted_endpoints . If they cannot access the endpoint, their request would be denied before any filter criteria is evaluated.","title":"Example"},{"location":"reference/access-control/#update-filters","text":"Update filters are used to configure the conditions that must be satisfied for a user to update a record in the data table. This ensures that a user has permission to set the fields they have included in their request body. If the filter criteria fails, then the request will be denied with an Unauthorized error. The checks are performed as follows: Use update_filters to determine if the user has permission to access the specified record. If no records are returned from the data table, then the record either does not exist or the user does not have permission to update it and a Not Found error will be returned. However, if a record is returned, then the user has permissions to update the record. Use update_fields_permitted , update_fields_restricted , and exclude_fields to determine if the user has permissions to update the fields they specified in the request body. If either of these criteria fail, the request will be denied with an Unauthorized error. Take the contents of the requested item from the data table and merge the user's desired changes with that item. Then, run the update_filters against this combined record. This will determine if the user has permission to make the changes they are requesting to the object. If the filter criteria fails, the request will be denied with an Unauthorized error stating which fields have invalid values. Finally, field validation runs as normal.","title":"Update Filters"},{"location":"reference/access-control/#example_1","text":"Let's say the user has these permissions: { \"update_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"eq\" , \"value\" : \"a\" } ] } The record they are trying to modify in the database looks like: { \"product\" : \"a\" , \"approved\" : false } If the user tries to perform the below update request: { \"product\" : \"b\" , \"approved\" : true } Then this request will be denied because the update_filters do not permit the user to modify the product key to any value that is not equal to \"a\". However, this update would be permitted because the product key is not being modified from its current value of \"a\": { \"approved\" : true , \"reason\" : \"approved by user\" } Now, let's say that the same user was trying to update the below record: { \"product\" : \"b\" , \"approved\" : false } If the user tried to perform the below request, it would be denied because they do not have permission to update an item where the product key is not equal to \"a\": { \"approved\" : true }","title":"Example"},{"location":"reference/access-control/#delete-filters","text":"Update filters are used to configure the conditions that must be satisfied for a user to delete a record in the data table. If the filter criteria fails, then the request will be denied with an Unauthorized error.","title":"Delete Filters"},{"location":"reference/access-control/#example_2","text":"Let's say the user has these permissions: { \"delete_filters\" : [ { \"field\" : \"product\" , \"operator\" : \"eq\" , \"value\" : \"a\" } ] } The record they are trying to delete in the database looks like: { \"product\" : \"a\" , \"approved\" : false } If the user tries to perform a delete request against that record, it would be permitted because the product key is equal to \"a\". However, if the user attempted to perform a delete request against the below record, it would be denied because the product key is not equal to \"a\": { \"product\" : \"b\" , \"approved\" : false }","title":"Example"},{"location":"reference/access-control/#filter-merging","text":"When a user is assigned multiple filters that target the same key, they are merged together using an OR operation. Then, those filters will be combined together with the filters for other keys using an AND operation. For example, if a user has the below read filters: { \"read_filters\" : [ // I n heri te d fr om group - a { \"field\" : \"product\" , \"operator\" : \"contains\" , \"value\" : \"Standard\" }, // I n heri te d fr om group - b { \"field\" : \"product\" , \"operator\" : \"ne\" , \"value\" : \"Standard Elite\" }, // I n heri te d fr om group - c { \"field\" : \"product_status\" , \"value\" : \"Active\" }, // I n heri te d fr om user { \"field\" : \"target_audience\" , \"value\" : \"Global\" } ] } The below filter expression would be generated: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" These filters will be further merged together with any filters the user specified using another AND operation. For instance, if the user performed these filters on their request: GET /products/?company=ABC&product_status=Pending The generated filter expression would be: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" AND company = \"ABC\" AND product_status = \"Pending\" This will actually produce no results because the filters product_status = \"Active\" and product_status = \"Pending\" are conflicting. The user is intentionally unable to override any filters defined by the administrator. If the user removed their filter for product_status = \"Pending\" and only filtered on company : GET /products/?company=ABC The generated filter expression would be: ( product CONTAINS \"Standard\" OR product != \"Standard Elite\" ) AND product_status = \"Active\" AND target_audience = \"Global\" AND company = \"ABC\" And any results that met that criteria would be returned","title":"Filter Merging"},{"location":"reference/access-control/#field-exclusions","text":"Field exclusions allow for excluding one or more fields from the output of all queries. These fields are from any output during the post-processing phase of all queries. Additionally, if a user attempts to create or update an item that contains a field from this list, the operation will be denied. Syntax [ \"field1\" , \"field2\" ]","title":"Field exclusions"},{"location":"reference/access-control/#permitted-endpoints","text":"Before taking any action, every call is validated to ensure the user has permissions to perform the call. For convenience, regular expressions can be used within the endpoint field. Syntax [ { \"method\" : \"GET|POST|PUT|DELETE\" , \"endpoint\" : \"/endpoint\" }, { \"method\" : \"GET|POST|PUT|DELETE\" , \"endpoint\" : \"^/endpoint2/.+$\" } ]","title":"Permitted endpoints"},{"location":"reference/access-control/#groups","text":"A group object be made up of: id - Identifier for the group permitted_endpoints - Optional list of permitted endpoints read_filters - Optional list of read filters create_filters - Optional list of create filters update_filters - Optional list of update filters delete_filters - Optional list of delete filters exclude_fields - Optional list of field exclusions update_fields_permitted - Optional list of the only fields that can be updated update_fields_restricted - Optional list of fields to restrict updates for The name of the group table must be passed in to the constructor.","title":"Groups"},{"location":"reference/access-control/#example_3","text":"{ \"id\" : \"read-only\" , \"permitted_endpoints\" : [ { \"endpoint\" : \"^/account/.+$\" , \"method\" : \"GET\" }, { \"endpoint\" : \"^/accounts.*$\" , \"method\" : \"GET\" }, { \"endpoint\" : \"^/search/.+$\" , \"method\" : \"POST\" } ], \"exclude_fields\" : [ \"field1\" ], \"update_fields_permitted\" : [ \"field4\" ], \"update_fields_restricted\" : [ \"field5\" ], \"read_filters\" : [ { \"field\" : \"field2\" , \"value\" : \"value1\" }, { \"field\" : \"field3\" , \"operator\" : \"in\" , \"value\" : [ \"value2\" , \"value3\" ] } ] }","title":"Example"},{"location":"reference/access-control/#auth-identifier","text":"An auth record is made up of: id - Identifier for the user/auth record username - Username for this user. This is optional when using OIDC since the information is filled by OIDC. name - Username for this user. This is optional when using OIDC since the information is filled by OIDC. email - Email for this user. This is optional when using OIDC since the information is filled by OIDC. groups - Optional list of groups this user is a member of permitted_endpoints - Optional list of permitted endpoints read_filters - Optional list of read filters create_filters - Optional list of create filters update_filters - Optional list of update filters delete_filters - Optional list of delete filters exclude_fields - Optional list of field exclusions update_fields_permitted - Optional list of the only fields that can be updated update_fields_restricted - Optional list of fields to restrict updates for","title":"Auth Identifier"},{"location":"reference/access-control/#types","text":"There are three types of accepted authentication identifiers: USERNAME OIDC_GROUP API_KEY Though not required, it is recommended for each object type to have a type key that corresponds to its authentication type (OIDC_GROUP, USERNAME, or API_KEY). The field requirements for each object type are outlined in the following sections","title":"Types"},{"location":"reference/access-control/#username","text":"id (primary key) - this is the user's username Though not required, it is recommended to also include a name field containing the user's full name to make it easier to identify the user at a glance.","title":"USERNAME"},{"location":"reference/access-control/#oidc_group","text":"id (primary key) - this is expected to be the group id Though not required, it is recommended to also include a name field containing the group's display name to make it easier to identify the group at a glance. If a user is a member of more than one OIDC group, the permissions granted by each configured group will be combined together to generate the effective permissions applied to the user.","title":"OIDC_GROUP"},{"location":"reference/access-control/#api_key","text":"id (primary key) - this is the api key id name username email","title":"API_KEY"},{"location":"reference/access-control/#groups_1","text":"Optionally, each auth object can include a groups object, which should be a list of group ids that the user is a member of: { \"groups\" : [ \"read-only\" , \"view-audit-logs\" ] } Any permissions defined in the groups are combined together to make up the user's permissions. In addition, the same permissions that a group defines ( read_filters , create_filters , update_filters , delete_filters , exclude_fields , update_fields_permitted , update_fields_restricted , permitted_endpoints ) can be expressed at the user level. These permissions will be combined together with the permissions outlined in the groups the user is a member of. Permissions defined at the user level DO NOT override those specified at the group level - they are combined. If a user is a member of multiple OIDC groups, the permissions are combined as explained in the filter merging section.","title":"Groups"},{"location":"reference/access-control/#example_4","text":"{ \"id\" : \"johndoe\" , \"type\" : \"API_KEY\" , \"username\" : \"johndoe\" , \"name\" : \"John Doe\" , \"email\" : \"john@doe.com\" , \"groups\" : [ \"read-only\" , \"standard-product-only\" ], \"read_filters\" : [ { \"field\" : \"product\" , \"value\" : \"Limited\" } ] }","title":"Example"},{"location":"reference/access-control/#audit-logs","text":"For every authorized, successful call to the API, an entry will be logged in the audit log table. Each record will follow the below format: { \"action\" : \"CREATE|UPDATE|DELETE|GET|LIST|SEARCH|{CUSTOM-ACTION}\" , \"body\" : { \"key\" : \"value\" }, \"method\" : \"HTTP method from API gateway\" , \"path\" : \"/endpoint/path\" , \"path_params\" : { \"key\" : \"value\" }, \"query_params\" : { \"key\" : \"value\" }, \"resource\" : { \"key\" : \"value\" }, \"time\" : \"2019-10-04T18:44:30.166635\" , \"user\" : { \"api_key_id\" : \"ID\" , \"name\" : \"John Doe\" , \"source_ip\" : \"1.2.3.4\" , \"username\" : \"222222222\" , \"user_agent\" : \"curl\" } } The following fields may not be included or may not have values for all types of actions: body query_params path_params resource","title":"Audit Logs"},{"location":"reference/authentication/","text":"The two types of authentication officially supported are via API Gateway or via OIDC. Helper functions have been created for each access control type to assist with passing the correct request format into Scoutr. You can alternatively configure a custom authenticator provider, as long as you provide the correct request information to Scoutr. API Gateway For API Gateway authentication, the request format is generated by the build_api_gateway_request method. Note Only Lambda payload version 1.0 is supported at this time. Example Refer to the example serverless endpoint OIDC It is assumed that there is an Apache server running in front of the application that performs OIDC authentication and passes the OIDC claims as headers. The simplest method to setup the API is to use Flask API . Helper methods have been provided to make the setup as simple as possible. The init_flask method automatically generates the belows endpoints: GET /user/ - Returns information about the authenticated user POST /user/has-permission/ - Determine if user has permission to access an endpoint. The body of this request should contain method and path keys as JSON. GET /<primary_list_endpoint>/ - Primary endpoint used to list data. The value of primary_list_endpoint is determined by an argument passed to init_flask() GET /audit/ - List and search all audit logs GET /audit/<item>/ - List audit logs for a particular resource GET /history/<item>/ - Show history for a particular resource POST /search/<search_key>/ - Search endpoint that allows searching by any key for one or more values. The body of this request should be a JSON list of values. Example Refer to the example flask application Custom It is easy to configure a custom authentication provider as long as you use the correct Request format. Each of the action-functions (i.e. list() , create() , update() , delete() , etc.) take a request argument that tells Scoutr about the request and the user who performed it. To submit a custom request, make sure to provide the following inputs correctly as shown in the below example: request = Request ( method = 'POST' , path = '/products/create/' , source_ip = '1.2.3.4' , user_agent = 'Postman' , body = { 'id' : '12345' , 'product' : 'Standard' , 'price' : 25 , 'date' : '2020-01-01T00:00:00Z' } path_params : { 'company' : 'Scoutr Solutions' }, query_params : { 'status' : [ 'Active' , 'Pending' ] }, user = RequestUser ( id = '123' , data = UserData ( username = '123' , name = 'John Doe' , email = 'john@doe.com' , entitlements = [ 'group1' , 'group2' , 'group3' ] ) ) ) Body The body should be the JSON body of the request that comes in a POST or PUT request. For other methods, body can be set to a null value. Path Parameters The path_params should be an object mapping a path parameter key to its value. { \"key1\" : \"value1\" , \"key2\" : \"value2\" } Query Parameters The query_params should be an object mapping a query parameter key to its values. The values must be an array, even if there is only a single value. { \"key\" : [ \"value1\" , \"value2\" ] } Request User The user key expects an instance of RequestUser that specifies, at minimum, an unique identifier for this user ( id ). If your custom provider knows more information about the user (i.e. name, email, username, OIDC group memberships), this information can be provided as UserData in the optional data key. It is expected that if your custom provider does not know how to identify the user's data, that the information is stored in the corresponding record in the auth table: { \"id\" : \"123\" , \"name\" : \"John Doe\" , \"email\" : \"john@doe.com\" , \"entitlements\" : [ \"group-a\" , \"group-b\" ] } Entitlements The entitlements key is used in most cases to specify that the user is a member of one or more OIDC groups. You should specify a unique identifier in the entitlements array for each group membership. Once the request reaches Scoutr, it will perform a lookup of each of these entitlement ids in the auth table to see if there are any records with that identifier. The permissions granted by each of those entitlements in the auth table will be inherited by the user.","title":"Authentication"},{"location":"reference/authentication/#api-gateway","text":"For API Gateway authentication, the request format is generated by the build_api_gateway_request method. Note Only Lambda payload version 1.0 is supported at this time.","title":"API Gateway"},{"location":"reference/authentication/#example","text":"Refer to the example serverless endpoint","title":"Example"},{"location":"reference/authentication/#oidc","text":"It is assumed that there is an Apache server running in front of the application that performs OIDC authentication and passes the OIDC claims as headers. The simplest method to setup the API is to use Flask API . Helper methods have been provided to make the setup as simple as possible. The init_flask method automatically generates the belows endpoints: GET /user/ - Returns information about the authenticated user POST /user/has-permission/ - Determine if user has permission to access an endpoint. The body of this request should contain method and path keys as JSON. GET /<primary_list_endpoint>/ - Primary endpoint used to list data. The value of primary_list_endpoint is determined by an argument passed to init_flask() GET /audit/ - List and search all audit logs GET /audit/<item>/ - List audit logs for a particular resource GET /history/<item>/ - Show history for a particular resource POST /search/<search_key>/ - Search endpoint that allows searching by any key for one or more values. The body of this request should be a JSON list of values.","title":"OIDC"},{"location":"reference/authentication/#example_1","text":"Refer to the example flask application","title":"Example"},{"location":"reference/authentication/#custom","text":"It is easy to configure a custom authentication provider as long as you use the correct Request format. Each of the action-functions (i.e. list() , create() , update() , delete() , etc.) take a request argument that tells Scoutr about the request and the user who performed it. To submit a custom request, make sure to provide the following inputs correctly as shown in the below example: request = Request ( method = 'POST' , path = '/products/create/' , source_ip = '1.2.3.4' , user_agent = 'Postman' , body = { 'id' : '12345' , 'product' : 'Standard' , 'price' : 25 , 'date' : '2020-01-01T00:00:00Z' } path_params : { 'company' : 'Scoutr Solutions' }, query_params : { 'status' : [ 'Active' , 'Pending' ] }, user = RequestUser ( id = '123' , data = UserData ( username = '123' , name = 'John Doe' , email = 'john@doe.com' , entitlements = [ 'group1' , 'group2' , 'group3' ] ) ) )","title":"Custom"},{"location":"reference/authentication/#body","text":"The body should be the JSON body of the request that comes in a POST or PUT request. For other methods, body can be set to a null value.","title":"Body"},{"location":"reference/authentication/#path-parameters","text":"The path_params should be an object mapping a path parameter key to its value. { \"key1\" : \"value1\" , \"key2\" : \"value2\" }","title":"Path Parameters"},{"location":"reference/authentication/#query-parameters","text":"The query_params should be an object mapping a query parameter key to its values. The values must be an array, even if there is only a single value. { \"key\" : [ \"value1\" , \"value2\" ] }","title":"Query Parameters"},{"location":"reference/authentication/#request-user","text":"The user key expects an instance of RequestUser that specifies, at minimum, an unique identifier for this user ( id ). If your custom provider knows more information about the user (i.e. name, email, username, OIDC group memberships), this information can be provided as UserData in the optional data key. It is expected that if your custom provider does not know how to identify the user's data, that the information is stored in the corresponding record in the auth table: { \"id\" : \"123\" , \"name\" : \"John Doe\" , \"email\" : \"john@doe.com\" , \"entitlements\" : [ \"group-a\" , \"group-b\" ] }","title":"Request User"},{"location":"reference/authentication/#entitlements","text":"The entitlements key is used in most cases to specify that the user is a member of one or more OIDC groups. You should specify a unique identifier in the entitlements array for each group membership. Once the request reaches Scoutr, it will perform a lookup of each of these entitlement ids in the auth table to see if there are any records with that identifier. The permissions granted by each of those entitlements in the auth table will be inherited by the user.","title":"Entitlements"},{"location":"reference/endpoint-structure/","text":"The helper methods within Scoutr assume that your API consists of the below endpoint types. List all records The list all items endpoint will return a list of all items within the backend that the user has permission to see and that meet any specified filter criteria. Serverless Example list : handler : endpoints.list.lambda_handler events : - http : path : items method : get private : true Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) try : api = DynamoAPI ( config ) data = api . list ( request = build_api_gateway_request ( event ) ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } List all unique values for a key The list by unique key endpoint is provided as a means to display all unique values for a single search key. It is implemented by specifying a value for the key argument of the list_unique_values() method. Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) try : api = DynamoAPI ( config ) data = api . list_unique_values ( request = build_api_gateway_request ( event ), key = 'product' ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } Search multiple values for a single search key The search endpoint enables users to lookup information about multiple items by utilizing a dynamic path variable (POST /search/{search_key} ). For example, if you wanted to search for records that had specific product key, you could submit the below request: POST /search/product With the body: [ \"Standard\" , \"Limited\" , \"Deluxe\" ] Would return the contents of records where product is one of \"Standard\", \"Limited\", or \"Deluxe\". Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get path parameters path_params = event [ 'pathParameters' ] query = json . loads ( event [ 'body' ]) search_key = path_params [ 'search_key' ] try : api = DynamoAPI ( config ) data = api . search ( request = build_api_gateway_request ( event ), key = search_key , values = query ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } Get single item by key If this returns more than one record, it will throw a BadRequestException . If no records are returned, a NotFoundException will be thrown. Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get item id item_id = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . get ( request = build_api_gateway_request ( event ), key = 'id' , value = item_id ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } Create item Refer to the data validation section for more information on validation. Implementation Example import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) item = json . loads ( event [ 'body' ]) try : api = DynamoAPI ( config ) data = api . create ( request = build_api_gateway_request ( event ), data = item , validation = VALIDATION ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } Update single item by key The update() method accepts a couple of arguments: primary_key Mapping of the primary key to value. For instance, if the table's primary key is id , it is expected this mapping would be: { 'id' : 'value' } data Dictionary of fields to be updated validation Dictionary of fields to perform validation against. Refer to the data validation section for more information. condition Conditional expression to apply on updates. This should be an instance of boto3's ConditionExpression . If the condition expression does not pass, a BadRequestException will be thrown. condition_failure_message By default, if the condition expression does not pass, it will return an error to the user stating \"Conditional check failed\". However, if this parameter is supplied, it will be returned to the user instead. Implementation Example import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) data = json . loads ( event [ 'body' ]) try : api = DynamoAPI ( config ) data = api . update ( request = build_api_gateway_request ( event ), data = data , validation = VALIDATION ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } Delete single item by key primary_key Mapping of the primary key to value. For instance, if the table's primary key is id , it is expected this mapping would be: { 'id' : 'value' } condition Conditional expression to apply on deletions. This should be an instance of boto3's ConditionExpression . If the condition expression does not pass, a BadRequestException will be thrown. condition_failure_message By default, if the condition expression does not pass, it will return an error to the user stating \"Conditional check failed\". However, if this parameter is supplied, it will be returned to the user instead. Implementation Example import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get item id item_id = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . delete ( request = build_api_gateway_request ( event ), primary_key = { 'id' : item_id } ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } List all audit logs This endpoint enables users to view and filter all of the audit logs. Note that field filter permissions do not apply to audit logs, but the permitted_endpoint permissions still do. Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Build request request = build_api_gateway_request ( event ) # Validate item id item = request . path_params . get ( 'item' ) if item : param_overrides = { 'resource.id' : item } else : param_overrides = {} try : api = DynamoAPI ( config ) data = api . list_audit_logs ( request = request , param_overrides = param_overrides ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) } View item history The history endpoint utilizes the audit logs to reconstruct snapshots of a record over time. A sample output is shown below: [ { \"data\" : { \"product\" : \"a\" , \"active_date\" : \"2019-12-17\" , \"status\" : \"Suspended\" }, \"time\" : \"2020-01-01T16:10:32.399907\" }, { \"data\" : { \"product\" : \"a\" , \"active_date\" : \"2019-12-17\" , \"status\" : \"Active\" }, \"time\" : \"2019-12-01T19:04:42.054592\" }, { \"data\" : { \"product\" : \"a\" , \"status\" : \"Created\" }, \"time\" : \"2019-01-01T00:00:00.000769\" } ] Implementation Example import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get parameters item = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . history ( request = build_api_gateway_request ( event ), key = 'id' , value = item ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Endpoint structure"},{"location":"reference/endpoint-structure/#list-all-records","text":"The list all items endpoint will return a list of all items within the backend that the user has permission to see and that meet any specified filter criteria.","title":"List all records"},{"location":"reference/endpoint-structure/#serverless-example","text":"list : handler : endpoints.list.lambda_handler events : - http : path : items method : get private : true","title":"Serverless Example"},{"location":"reference/endpoint-structure/#implementation-example","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) try : api = DynamoAPI ( config ) data = api . list ( request = build_api_gateway_request ( event ) ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#list-all-unique-values-for-a-key","text":"The list by unique key endpoint is provided as a means to display all unique values for a single search key. It is implemented by specifying a value for the key argument of the list_unique_values() method.","title":"List all unique values for a key"},{"location":"reference/endpoint-structure/#implementation-example_1","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) try : api = DynamoAPI ( config ) data = api . list_unique_values ( request = build_api_gateway_request ( event ), key = 'product' ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#search-multiple-values-for-a-single-search-key","text":"The search endpoint enables users to lookup information about multiple items by utilizing a dynamic path variable (POST /search/{search_key} ). For example, if you wanted to search for records that had specific product key, you could submit the below request: POST /search/product With the body: [ \"Standard\" , \"Limited\" , \"Deluxe\" ] Would return the contents of records where product is one of \"Standard\", \"Limited\", or \"Deluxe\".","title":"Search multiple values for a single search key"},{"location":"reference/endpoint-structure/#implementation-example_2","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get path parameters path_params = event [ 'pathParameters' ] query = json . loads ( event [ 'body' ]) search_key = path_params [ 'search_key' ] try : api = DynamoAPI ( config ) data = api . search ( request = build_api_gateway_request ( event ), key = search_key , values = query ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#get-single-item-by-key","text":"If this returns more than one record, it will throw a BadRequestException . If no records are returned, a NotFoundException will be thrown.","title":"Get single item by key"},{"location":"reference/endpoint-structure/#implementation-example_3","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get item id item_id = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . get ( request = build_api_gateway_request ( event ), key = 'id' , value = item_id ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#create-item","text":"Refer to the data validation section for more information on validation.","title":"Create item"},{"location":"reference/endpoint-structure/#implementation-example_4","text":"import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) item = json . loads ( event [ 'body' ]) try : api = DynamoAPI ( config ) data = api . create ( request = build_api_gateway_request ( event ), data = item , validation = VALIDATION ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#update-single-item-by-key","text":"The update() method accepts a couple of arguments: primary_key Mapping of the primary key to value. For instance, if the table's primary key is id , it is expected this mapping would be: { 'id' : 'value' } data Dictionary of fields to be updated validation Dictionary of fields to perform validation against. Refer to the data validation section for more information. condition Conditional expression to apply on updates. This should be an instance of boto3's ConditionExpression . If the condition expression does not pass, a BadRequestException will be thrown. condition_failure_message By default, if the condition expression does not pass, it will return an error to the user stating \"Conditional check failed\". However, if this parameter is supplied, it will be returned to the user instead.","title":"Update single item by key"},{"location":"reference/endpoint-structure/#implementation-example_5","text":"import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) data = json . loads ( event [ 'body' ]) try : api = DynamoAPI ( config ) data = api . update ( request = build_api_gateway_request ( event ), data = data , validation = VALIDATION ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#delete-single-item-by-key","text":"primary_key Mapping of the primary key to value. For instance, if the table's primary key is id , it is expected this mapping would be: { 'id' : 'value' } condition Conditional expression to apply on deletions. This should be an instance of boto3's ConditionExpression . If the condition expression does not pass, a BadRequestException will be thrown. condition_failure_message By default, if the condition expression does not pass, it will return an error to the user stating \"Conditional check failed\". However, if this parameter is supplied, it will be returned to the user instead.","title":"Delete single item by key"},{"location":"reference/endpoint-structure/#implementation-example_6","text":"import json import os import re from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI from scoutr.utils import value_in_set try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry PRODUCTS = { 'a' , 'b' , 'c' } VALIDATION = { 'product' : lambda value , item , existing_item : value_in_set ( value = value , valid_options = PRODUCTS , option_name = 'product' ), 'date' : lambda value , item , existing_item : { 'result' : re . match ( '^\\d {4} -\\d {2} -\\d {2} $' , value ), 'message' : 'Date must be formatted as YYYY-MM-DD' } } def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get item id item_id = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . delete ( request = build_api_gateway_request ( event ), primary_key = { 'id' : item_id } ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#list-all-audit-logs","text":"This endpoint enables users to view and filter all of the audit logs. Note that field filter permissions do not apply to audit logs, but the permitted_endpoint permissions still do.","title":"List all audit logs"},{"location":"reference/endpoint-structure/#implementation-example_7","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Build request request = build_api_gateway_request ( event ) # Validate item id item = request . path_params . get ( 'item' ) if item : param_overrides = { 'resource.id' : item } else : param_overrides = {} try : api = DynamoAPI ( config ) data = api . list_audit_logs ( request = request , param_overrides = param_overrides ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/endpoint-structure/#view-item-history","text":"The history endpoint utilizes the audit logs to reconstruct snapshots of a record over time. A sample output is shown below: [ { \"data\" : { \"product\" : \"a\" , \"active_date\" : \"2019-12-17\" , \"status\" : \"Suspended\" }, \"time\" : \"2020-01-01T16:10:32.399907\" }, { \"data\" : { \"product\" : \"a\" , \"active_date\" : \"2019-12-17\" , \"status\" : \"Active\" }, \"time\" : \"2019-12-01T19:04:42.054592\" }, { \"data\" : { \"product\" : \"a\" , \"status\" : \"Created\" }, \"time\" : \"2019-01-01T00:00:00.000769\" } ]","title":"View item history"},{"location":"reference/endpoint-structure/#implementation-example_8","text":"import json import os from scoutr.exceptions import HttpException from scoutr.helpers.api_gateway import build_api_gateway_request , handle_http_exception from scoutr.models.config import Config from scoutr.providers.aws import DynamoAPI try : import sentry_sdk except ImportError : from scoutr.utils import mock_sentry sentry_sdk = mock_sentry def lambda_handler ( event , context ): config = Config ( data_table = os . getenv ( 'TableName' ), auth_table = os . getenv ( 'AuthTable' ), group_table = os . getenv ( 'GroupTable' ), audit_table = os . getenv ( 'AuditTable' ), primary_key = 'id' ) # Get parameters item = event [ 'pathParameters' ][ 'id' ] try : api = DynamoAPI ( config ) data = api . history ( request = build_api_gateway_request ( event ), key = 'id' , value = item ) except HttpException as e : if e . status == 500 : sentry_sdk . capture_exception ( e ) return handle_http_exception ( e ) except Exception as e : return { 'statusCode' : 500 , 'body' : json . dumps ({ 'error' : str ( e )}) } return { 'statusCode' : 200 , 'body' : json . dumps ( data ) }","title":"Implementation Example"},{"location":"reference/error-tracking/","text":"Error tracking Support for Sentry is built-in to Scoutr in Python. Error tracking will be added to Scoutr in Go at a later time. Breadcrumbs are automatically added in at key points in the execution. To enable error tracking, install the sentry-sdk package: pip install sentry-sdk And then initialize Sentry at the start of your code: import os import sentry_sdk from sentry_sdk.integrations.aws_lambda import AwsLambdaIntegration sentry_sdk . init ( dsn = os . getenv ( 'SENTRY_DSN' ), integrations = [ AwsLambdaIntegration ()], environment = os . getenv ( 'ENV' ) ) Refer to the examples to see sample usage of Sentry.","title":"Error tracking"},{"location":"reference/error-tracking/#error-tracking","text":"Support for Sentry is built-in to Scoutr in Python. Error tracking will be added to Scoutr in Go at a later time. Breadcrumbs are automatically added in at key points in the execution. To enable error tracking, install the sentry-sdk package: pip install sentry-sdk And then initialize Sentry at the start of your code: import os import sentry_sdk from sentry_sdk.integrations.aws_lambda import AwsLambdaIntegration sentry_sdk . init ( dsn = os . getenv ( 'SENTRY_DSN' ), integrations = [ AwsLambdaIntegration ()], environment = os . getenv ( 'ENV' ) ) Refer to the examples to see sample usage of Sentry.","title":"Error tracking"},{"location":"reference/filtering/","text":"There are two levels of filtering that are supported: Path-based filtering Query string-based filtering Most of the time, query string-based filtering will serve the purpose unless you want your URLs to look a specific way, in which path-based filtering can be advantageous: To search for records where product is equal to \"a\": /endpoint/product/a Dynamic path filters The list action supports dynamic path filtering. When search_key and search_value are passed into the method as path parameters in the Request , it will dynamically modify the path parameters to construct a search filter where search_key = search_value To configure this, setup path parameters on the resource: /endpoint/{search_key}/{search_value} When using serverless.yml for API Gateway : events : - http : path : endpoint method : get private : true - http : path : endpoint/{search_key}/{search_value} method : get private : true When using the dynamic path filters, there is no need to construct additional endpoints that support filtering by a specific key. However, using this method provides no limitations over what fields can be used as a filter. If that is a concern for your API, you will need to construct static path filters. Static path filters Static path filters can be constructed in a similar manner to the dynamic path filters, except that the search key is manually specified: /endpoint/status/{status} In order to properly work, the path variable must exactly match the key in the backend table that you want to perform the filter against. Query String Filters In addition to path filters, query string filtering is also supported. The Request accepts a query_params argument. Each querystring should be a field_name=search_value format: /endpoint?status=Active&field3=value2 Path parameters always take precedence over querystring parameters. The below query: /endpoint/field2/value1?status=Active&field2=value2 Would result in this filter criteria: field2 = value1 AND status = Active Operators For more complex queries, querystring search supports operators that can be used to further customize how the data is filtered. Supported Operators Operator Description Syntax Providers eq Value is equal to data=abc OR data__eq=abc All providers ne Value is not equal to data__ne=abc All providers in Value is in list data__in=[\"value1\", \"value2\"] All providers notin Value is not in list data__notin=[\"value1\", \"value2\"] All providers startswith String starts with data__startswith=abc DynamoDB MongoDB contains Strings contains data__contains=abc DynamoDB MongoDB notcontains String does not contain data__notcontains=abc DynamoDB MongoDB exists Attribute exists / not exists data__exists=true OR data__exists=false DynamoDB MongoDB gt Greater than data__gt=20 All providers lt Less than data__lt=20 All providers gte Greater than or equal data__gte=20 All providers lte Less than or equal data__lte=20 All providers between Value is between data__between=[10, 20] All providers regex Regular expression data__regex=^ab.*c$ MongoDB type Value is the specified type data__type=array MongoDB haselements Value has the specified elements data__haselements=[\"value1\", \"value2\"] OR data__haselements={\"key\": \"value\"} MongoDB Usage To use an operator, append __operator to the key name. For example: To search for all items with the field1 key containing the phrase \"val\" /items?field1__contains=val To search for all items with the field1 key starting with the phrase \"va\" /items?field1__startswith=va Usage of all the operators is straightforward, with the exception of the in , betweeen , and haselements operators. The in operators checks to see if the the value is included in a list of options. It should follow the JSON list syntax: /items?field1__in=[\"value1\", \"value2\"] The between operator checks to see if the value is, inclusively, between a low and high value. It should also follow a JSON list syntax: /items?num__between=[0, 3] It also works for string values, such as two dates: /items?date__between=[\"2019-01-01\", \"2019-12-31\"] To find items that have an attribute: /items?name__exists=true To search for items that do not have an attribute: /items?name__exists=false For MongoDB, haselements operator can be used to check if an array has one or more values: /items?data__haselements=[\"value1\", \"value2\"] Or it can be used to check if an object has a key-value pair: /items?data__haselements={\"key\": \"value\"}","title":"Filtering"},{"location":"reference/filtering/#dynamic-path-filters","text":"The list action supports dynamic path filtering. When search_key and search_value are passed into the method as path parameters in the Request , it will dynamically modify the path parameters to construct a search filter where search_key = search_value To configure this, setup path parameters on the resource: /endpoint/{search_key}/{search_value} When using serverless.yml for API Gateway : events : - http : path : endpoint method : get private : true - http : path : endpoint/{search_key}/{search_value} method : get private : true When using the dynamic path filters, there is no need to construct additional endpoints that support filtering by a specific key. However, using this method provides no limitations over what fields can be used as a filter. If that is a concern for your API, you will need to construct static path filters.","title":"Dynamic path filters"},{"location":"reference/filtering/#static-path-filters","text":"Static path filters can be constructed in a similar manner to the dynamic path filters, except that the search key is manually specified: /endpoint/status/{status} In order to properly work, the path variable must exactly match the key in the backend table that you want to perform the filter against.","title":"Static path filters"},{"location":"reference/filtering/#query-string-filters","text":"In addition to path filters, query string filtering is also supported. The Request accepts a query_params argument. Each querystring should be a field_name=search_value format: /endpoint?status=Active&field3=value2 Path parameters always take precedence over querystring parameters. The below query: /endpoint/field2/value1?status=Active&field2=value2 Would result in this filter criteria: field2 = value1 AND status = Active","title":"Query String Filters"},{"location":"reference/filtering/#operators","text":"For more complex queries, querystring search supports operators that can be used to further customize how the data is filtered.","title":"Operators"},{"location":"reference/filtering/#supported-operators","text":"Operator Description Syntax Providers eq Value is equal to data=abc OR data__eq=abc All providers ne Value is not equal to data__ne=abc All providers in Value is in list data__in=[\"value1\", \"value2\"] All providers notin Value is not in list data__notin=[\"value1\", \"value2\"] All providers startswith String starts with data__startswith=abc DynamoDB MongoDB contains Strings contains data__contains=abc DynamoDB MongoDB notcontains String does not contain data__notcontains=abc DynamoDB MongoDB exists Attribute exists / not exists data__exists=true OR data__exists=false DynamoDB MongoDB gt Greater than data__gt=20 All providers lt Less than data__lt=20 All providers gte Greater than or equal data__gte=20 All providers lte Less than or equal data__lte=20 All providers between Value is between data__between=[10, 20] All providers regex Regular expression data__regex=^ab.*c$ MongoDB type Value is the specified type data__type=array MongoDB haselements Value has the specified elements data__haselements=[\"value1\", \"value2\"] OR data__haselements={\"key\": \"value\"} MongoDB","title":"Supported Operators"},{"location":"reference/filtering/#usage","text":"To use an operator, append __operator to the key name. For example: To search for all items with the field1 key containing the phrase \"val\" /items?field1__contains=val To search for all items with the field1 key starting with the phrase \"va\" /items?field1__startswith=va Usage of all the operators is straightforward, with the exception of the in , betweeen , and haselements operators. The in operators checks to see if the the value is included in a list of options. It should follow the JSON list syntax: /items?field1__in=[\"value1\", \"value2\"] The between operator checks to see if the value is, inclusively, between a low and high value. It should also follow a JSON list syntax: /items?num__between=[0, 3] It also works for string values, such as two dates: /items?date__between=[\"2019-01-01\", \"2019-12-31\"] To find items that have an attribute: /items?name__exists=true To search for items that do not have an attribute: /items?name__exists=false For MongoDB, haselements operator can be used to check if an array has one or more values: /items?data__haselements=[\"value1\", \"value2\"] Or it can be used to check if an object has a key-value pair: /items?data__haselements={\"key\": \"value\"}","title":"Usage"},{"location":"reference/validation/","text":"Data validation on all create and update calls is supported. In order to implement the validation, a dictionary should be passed to the validation argument of the create() or update() methods of the provider. Required Fields To require that specific fields exist in a CREATE request, specify those fields in the required_fields argument: Python api . create ( request , data , required_fields = ( \"product\" , \"region\" )) Go requiredFields := [] string { \"product\" , \"region\" } api . Create ( request , body , validation , requiredFields ) Syntax Python FIELD_VALIDATION = { 'field_name_1' : lambda value , item , existing_item : callable_that_returns_a_bool , 'field_name_2' : lambda value , item , existing_item : callable_that_returns_a_dict , 'field_name_3' : callable_that_returns_a_bool , 'field_name_4' : callable_that_returns_a_dict } Go validation := map [ string ] utils . FieldValidation { \"field1\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { if value != \"hello\" { return false , fmt . Sprintf ( \"Invalid value '%s' for attribute 'field1'\" , value ), nil } return true , \"\" , nil }, \"field2\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { if value != \"world\" { return false , fmt . Sprintf ( \"Invalid value '%s' for attribute 'field2'\" , value ), nil } return true , \"\" , nil }, } The key of each item in the dictionary should match a field name that you want to perform validation against. The corresponding value for the key should be a callable that either returns a boolean or an object formatted as: Python { 'result' : boolean that indicates whether this field was valid or not , 'message' : 'custom error message to return to the user' } Go The function should have an output of ( bool , string , error ) For instance: return true | false , \"custom error message to return to the user\" , err | nil The callable that you provide can either be a function or a lambda. The method signature of both options must accept three arguments: value (Type: string ) - Contains the input value for this field item (Type: dict / map[string]interface{} ) - Contains the entire data object that was passed from the user existing_item (Type: dict / map[string]interface{} ) - Contains the existing data object in the data table. This will only have a value on update calls. For create calls, this will be None . Example Python import re from scoutr.utils import value_in_set def validate_user ( value , item , existing_item = None ): if isinstance ( existing_item , dict ): item_type = existing_item . get ( 'type' ) else : item_type = item . get ( 'type' ) if not item_type : return { 'result' : False , 'message' : 'Type field is required' } if item_type == '1' : return { 'result' : re . match ( '^\\d {9} $' , value ), 'message' : 'Invalid user for type %s ' % item_type } elif item_type == '2' : return { 'result' : re . match ( '^.+@example.com$' , value ), 'message' : 'Invalid user for type %s ' % item_type } else : return False FIELD_VALIDATION = { 'user' : validate_user , 'type' : lambda value , item , existing_item : value_in_set ( value = value , valid_options { '1' , '2' }, option_name = 'type' ), 'description' : lambda value , item , existing_item : isinstance ( value , str ), 'name' : lambda value , item , existing_item : { 'result' : re . match ( '^\\w+ \\w+$' , value ), 'message' : 'Invalid name format' } } Go import ( \"fmt\" \"regexp\" \"github.com/MichaelPalmer1/scoutr-go/utils\" ) func validateUser ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { var itemType string if existingItem != nil { itemType = existingItem [ \"type\" ] } else { itemType = item [ \"type\" ] } if _ , ok := item [ \"type\" ]; ! ok { return false , \"Type field is required\" , nil } if itemType == \"Type1\" { re := regexp . MustCompile ( \"^\\\\d{10}$\" ) if re . MatchString ( value ) { return true , \"\" , nil } else { return false , \"Value does not match pattern\" , nil } } else if itemType == \"Type2\" { re := regexp . MustCompile ( \"^[a-z]+$\" ) if re . MatchString ( value ) { return true , \"\" , nil } else { return false , \"Value does not match pattern\" , nil } } else { return false , \"Validation failed\" , nil } } fieldValidation := map [ string ] utils . FieldValidation { \"user\" : validateUser , \"type\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { validOptions := [] string { \"ABC\" , \"DEF\" } found := false for _ , item := range validOptions { if item == value { found = true break } } if ! found { return false , fmt . Sprintf ( \"Invalid value. Supported options are %s\" , validOptions ), nil } } }","title":"Validation"},{"location":"reference/validation/#required-fields","text":"To require that specific fields exist in a CREATE request, specify those fields in the required_fields argument: Python api . create ( request , data , required_fields = ( \"product\" , \"region\" )) Go requiredFields := [] string { \"product\" , \"region\" } api . Create ( request , body , validation , requiredFields )","title":"Required Fields"},{"location":"reference/validation/#syntax","text":"Python FIELD_VALIDATION = { 'field_name_1' : lambda value , item , existing_item : callable_that_returns_a_bool , 'field_name_2' : lambda value , item , existing_item : callable_that_returns_a_dict , 'field_name_3' : callable_that_returns_a_bool , 'field_name_4' : callable_that_returns_a_dict } Go validation := map [ string ] utils . FieldValidation { \"field1\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { if value != \"hello\" { return false , fmt . Sprintf ( \"Invalid value '%s' for attribute 'field1'\" , value ), nil } return true , \"\" , nil }, \"field2\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { if value != \"world\" { return false , fmt . Sprintf ( \"Invalid value '%s' for attribute 'field2'\" , value ), nil } return true , \"\" , nil }, } The key of each item in the dictionary should match a field name that you want to perform validation against. The corresponding value for the key should be a callable that either returns a boolean or an object formatted as: Python { 'result' : boolean that indicates whether this field was valid or not , 'message' : 'custom error message to return to the user' } Go The function should have an output of ( bool , string , error ) For instance: return true | false , \"custom error message to return to the user\" , err | nil The callable that you provide can either be a function or a lambda. The method signature of both options must accept three arguments: value (Type: string ) - Contains the input value for this field item (Type: dict / map[string]interface{} ) - Contains the entire data object that was passed from the user existing_item (Type: dict / map[string]interface{} ) - Contains the existing data object in the data table. This will only have a value on update calls. For create calls, this will be None .","title":"Syntax"},{"location":"reference/validation/#example","text":"Python import re from scoutr.utils import value_in_set def validate_user ( value , item , existing_item = None ): if isinstance ( existing_item , dict ): item_type = existing_item . get ( 'type' ) else : item_type = item . get ( 'type' ) if not item_type : return { 'result' : False , 'message' : 'Type field is required' } if item_type == '1' : return { 'result' : re . match ( '^\\d {9} $' , value ), 'message' : 'Invalid user for type %s ' % item_type } elif item_type == '2' : return { 'result' : re . match ( '^.+@example.com$' , value ), 'message' : 'Invalid user for type %s ' % item_type } else : return False FIELD_VALIDATION = { 'user' : validate_user , 'type' : lambda value , item , existing_item : value_in_set ( value = value , valid_options { '1' , '2' }, option_name = 'type' ), 'description' : lambda value , item , existing_item : isinstance ( value , str ), 'name' : lambda value , item , existing_item : { 'result' : re . match ( '^\\w+ \\w+$' , value ), 'message' : 'Invalid name format' } } Go import ( \"fmt\" \"regexp\" \"github.com/MichaelPalmer1/scoutr-go/utils\" ) func validateUser ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { var itemType string if existingItem != nil { itemType = existingItem [ \"type\" ] } else { itemType = item [ \"type\" ] } if _ , ok := item [ \"type\" ]; ! ok { return false , \"Type field is required\" , nil } if itemType == \"Type1\" { re := regexp . MustCompile ( \"^\\\\d{10}$\" ) if re . MatchString ( value ) { return true , \"\" , nil } else { return false , \"Value does not match pattern\" , nil } } else if itemType == \"Type2\" { re := regexp . MustCompile ( \"^[a-z]+$\" ) if re . MatchString ( value ) { return true , \"\" , nil } else { return false , \"Value does not match pattern\" , nil } } else { return false , \"Validation failed\" , nil } } fieldValidation := map [ string ] utils . FieldValidation { \"user\" : validateUser , \"type\" : func ( value string , item map [ string ] string , existingItem map [ string ] string ) ( bool , string , error ) { validOptions := [] string { \"ABC\" , \"DEF\" } found := false for _ , item := range validOptions { if item == value { found = true break } } if ! found { return false , fmt . Sprintf ( \"Invalid value. Supported options are %s\" , validOptions ), nil } } }","title":"Example"}]}